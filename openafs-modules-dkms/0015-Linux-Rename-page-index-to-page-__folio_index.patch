From d99f2503dd0b8317cf7170a9e00263796d88ee26 Mon Sep 17 00:00:00 2001
From: Cheyenne Wills <cwills@sinenomine.net>
Date: Thu, 31 Jul 2025 09:03:10 -0600
Subject: [PATCH 15/16] Linux: Rename page->index to page->__folio_index

The Linux 6.16 commit:
    'mm: rename page->index to page->__folio_index' (acc53a0b4c156)

simply renamed the field.

Add a autoconf test for page->__folio_index.

Create a getter wrapper function, afs_page_index(), that returns
page->__folio_index/page->index.

Update code that references the page->index with afs_page_index().

Note: Older code that is not conditionally not built for Linux 6.16
(e.g. afs_linux_bypass_readpages and afs_linux_readpages) was not
updated to use the wrapper.

Reviewed-on: https://gerrit.openafs.org/16439
Tested-by: BuildBot <buildbot@rampaginggeek.com>
Reviewed-by: Michael Meffie <mmeffie@sinenomine.net>
Reviewed-by: Andrew Deason <adeason@sinenomine.net>
(cherry picked from commit 24fdeefe16688d6a5cb7499a22df49d2c5ff9011)

Change-Id: Ide2f3a6513a006887db2cc6d7fdef2df33dec347
---
 src/afs/LINUX/osi_compat.h    | 12 ++++++++++++
 src/afs/LINUX/osi_vnodeops.c  |  6 +++---
 src/cf/linux-kernel-struct.m4 |  3 +++
 3 files changed, 18 insertions(+), 3 deletions(-)

diff --git a/src/afs/LINUX/osi_compat.h b/src/afs/LINUX/osi_compat.h
index 31687d02e..8a53d3487 100644
--- a/src/afs/LINUX/osi_compat.h
+++ b/src/afs/LINUX/osi_compat.h
@@ -310,6 +310,18 @@ afs_linux_cred_is_current(afs_ucred_t *cred)
 }
 #endif
 
+/* Folio / Page wrappers */
+
+static inline pgoff_t
+afs_page_index(struct page *p)
+{
+#if defined(STRUCT_PAGE_HAS___FOLIO_INDEX)
+    return p->__folio_index;
+#else
+    return p->index;
+#endif
+}
+
 #ifndef HAVE_LINUX_PAGE_OFFSET
 static inline loff_t
 page_offset(struct page *pp)
diff --git a/src/afs/LINUX/osi_vnodeops.c b/src/afs/LINUX/osi_vnodeops.c
index 10c03091d..c5c7b2f09 100644
--- a/src/afs/LINUX/osi_vnodeops.c
+++ b/src/afs/LINUX/osi_vnodeops.c
@@ -2756,7 +2756,7 @@ afs_linux_bypass_readahead(struct readahead_control *rac)
 	}
 
 	isize = (i_size_read(fp->f_mapping->host) - 1) >> PAGE_SHIFT;
-	if (pp->index > isize) {
+	if (afs_page_index(pp) > isize) {
 	    if (afs_FolioLocked(pp)) {
 		afs_unlock_folio(pp);
 	    }
@@ -2767,10 +2767,10 @@ afs_linux_bypass_readahead(struct readahead_control *rac)
 	if (page_ix == 0) {
 	    offset = page_offset(pp);
 	    ancr->offset = ancr->auio->uio_offset = offset;
-	    base_index = pp->index;
+	    base_index = afs_page_index(pp);
 	}
 	iovecp[page_ix].iov_len = PAGE_SIZE;
-	if (base_index != pp->index) {
+	if (base_index != afs_page_index(pp)) {
 	    if (afs_FolioLocked(pp)) {
 		 afs_unlock_folio(pp);
 	    }
diff --git a/src/cf/linux-kernel-struct.m4 b/src/cf/linux-kernel-struct.m4
index 5cd346fb5..24841e9f3 100644
--- a/src/cf/linux-kernel-struct.m4
+++ b/src/cf/linux-kernel-struct.m4
@@ -60,6 +60,9 @@ AC_CHECK_LINUX_STRUCT([task_struct], [sigmask_lock], [sched.h])
 AC_CHECK_LINUX_STRUCT([task_struct], [tgid], [sched.h])
 AC_CHECK_LINUX_STRUCT([task_struct], [thread_info], [sched.h])
 AC_CHECK_LINUX_STRUCT([task_struct], [total_link_count], [sched.h])
+dnl Linux 6.16 changed page.index to page.__folio_index;
+AC_CHECK_LINUX_STRUCT([page], [__folio_index], [mm_types.h])
+
 LINUX_SCHED_STRUCT_TASK_STRUCT_HAS_SIGNAL_RLIM
 
 dnl Check for typed structure elements
-- 
2.50.1

