From 902a669d9899308b5d1828b4ed01622ddf2b9f39 Mon Sep 17 00:00:00 2001
From: Cheyenne Wills <cwills@sinenomine.net>
Date: Thu, 31 Jul 2025 11:27:53 -0600
Subject: [PATCH 16/18] linux: convert aops->writepage to writepages

As part of the transition from pages to folios, the Linux 6.16 commit:
'fs: Remove aops->writepage' (6b0dfabb35550)

removes the writepage member from the address space operations and now
requires the writepages member.

An earlier Linux commit converted the underlying support of writepages
to use folios. The Linux 6.3 commit:
'fs: convert writepage_t callback to pass a folio' (d585bdbeb79aa)

requires the callback function passed to write_cache_pages() to expect a
folio instead of a page.

Since the aops->writepages member predates Linux 2.6.18, testing for
its presence is not an accurate check. Instead, we check to see if the
write_cache_pages() function takes a callback that uses folios (the
d585bdbeb79aa commit).

To implement this, afs_linux_write_pages() is added for
afs_file_aops.writepages. This function calls write_cache_pages(), which
uses the new afs_linux_writefolio_cb() callback to process the folios.
The callback's implementation is based on the logic from
afs_linux_writepage() but is updated to operate directly on folios. This
ensures that multi-page folios are handled correctly, rather than only
processing the head page of a folio.

Note, this change is retroactive back to linux 6.3.

Note, According to the Linux documentation for write_cache_pages, the
return value from the writepages should either be 0, or a negative error
code.  However the existing writepage code can return a positive value
(the residual for a partial write). For this commit, the existing
behavior of returning a residual is preserved.

Reviewed-on: https://gerrit.openafs.org/16437
Tested-by: BuildBot <buildbot@rampaginggeek.com>
Reviewed-by: Michael Meffie <mmeffie@sinenomine.net>
Reviewed-by: Andrew Deason <adeason@sinenomine.net>
(cherry picked from commit b2c039541d66e0760e7afe8b60539a00778fbfe2)

Change-Id: I98d9e4f49fb881a3c076f2caad54649750aca7a6
---
 src/afs/LINUX/osi_vnodeops.c    | 102 ++++++++++++++++++++++++++++++--
 src/cf/linux-kernel-assorted.m4 |   1 +
 src/cf/linux-test4.m4           |  22 ++++++-
 3 files changed, 120 insertions(+), 5 deletions(-)

diff --git a/src/afs/LINUX/osi_vnodeops.c b/src/afs/LINUX/osi_vnodeops.c
index c5c7b2f09..fe4c10b9e 100644
--- a/src/afs/LINUX/osi_vnodeops.c
+++ b/src/afs/LINUX/osi_vnodeops.c
@@ -3474,12 +3474,101 @@ afs_linux_end_writeback(struct vcache *vcp, cred_t **acredp, int written_size, u
     return code;
 }
 
+#if defined(LINUX_WRITEPAGES_USES_FOLIOS)
+/*
+ * Callback function for write_cache_pages
+ */
 static int
-#ifdef AOP_WRITEPAGE_TAKES_WRITEBACK_CONTROL
+afs_linux_writefolio_cb(struct folio *folio, struct writeback_control *wbc, void *priv)
+{
+    struct inode *inode;
+    struct page *pp;
+    struct address_space *mapping;
+    struct vcache *vcp;
+    cred_t *credp;
+    loff_t isize;
+
+    unsigned int to;
+
+    int code = 0;
+    int code1 = 0;
+
+    folio_get(folio);
+
+    pp = folio_page(folio, 0);
+    mapping = folio->mapping;
+    to = folio_size(folio);
+
+    inode = mapping->host;
+    vcp = VTOAFS(inode);
+    isize = i_size_read(inode);
+
+    /* Don't defeat an earlier truncate */
+    if (folio_pos(folio) >= isize) {
+	folio_start_writeback(folio);
+	folio_unlock(folio);
+	goto done;
+    }
+    code = afs_linux_begin_writeback(vcp, &credp);
+    if (code == AOP_WRITEPAGE_ACTIVATE) {
+	/* WRITEPAGE_ACTIVATE is the only return value that permits us
+	 * to return with the folio still locked */
+	return code;
+    }
+
+    folio_start_writeback(folio);
+
+    folio_mark_uptodate(folio);
+
+    /* We can unlock the folio here, because it's protected by the
+     * folio_writeback flag. This should make us less vulnerable to
+     * deadlocking in afs_write and afs_DoPartialWrite
+     */
+    folio_unlock(folio);
+
+    /* If this is the final folio, then just write the number of bytes that
+     * are actually in it */
+    if ((isize - folio_pos(folio)) < to) {
+	to = isize - folio_pos(folio);
+    }
+
+    code = afs_linux_page_writeback(inode, pp, 0, to, credp);
+
+    code1 = afs_linux_end_writeback(vcp, &credp, code, to);
+
+ done:
+    folio_end_writeback(folio);
+    folio_put(folio);
+
+    /* code1 is either 0, or the error code from a partial write */
+    if (code1) {
+	return code1;
+    }
+
+    /* code is either 0, the negative error code from afs_write, or the size of
+     * the data that wasn't written by afs_write.
+     * "to" is the amount of data that was requested to be written.
+     */
+    if (code == to) {
+	return 0;
+    }
+
+    return code;
+}
+
+static int
+afs_linux_write_pages(struct address_space *mapping, struct writeback_control *wbc)
+{
+    return write_cache_pages(mapping, wbc, afs_linux_writefolio_cb, NULL);
+}
+
+#else /* LINUX_WRITEPAGES_USES_FOLIOS */
+static int
+# ifdef AOP_WRITEPAGE_TAKES_WRITEBACK_CONTROL
 afs_linux_writepage(struct page *pp, struct writeback_control *wbc)
-#else
+# else
 afs_linux_writepage(struct page *pp)
-#endif
+# endif
 {
     struct address_space *mapping = pp->mapping;
     struct inode *inode;
@@ -3541,6 +3630,7 @@ done:
 
     return code;
 }
+#endif /* LINUX_WRITEPAGES_USES_FOLIOS */
 
 /* afs_linux_permission
  * Check access rights - returns error if can't check or permission denied.
@@ -3831,9 +3921,13 @@ static struct address_space_operations afs_file_aops = {
 #if defined(STRUCT_ADDRESS_SPACE_OPERATIONS_HAS_READAHEAD)
   .readahead =		afs_linux_readahead,
 #else
-  .readpages = 		afs_linux_readpages,
+  .readpages =		afs_linux_readpages,
 #endif
+#if defined(LINUX_WRITEPAGES_USES_FOLIOS)
+  .writepages =		afs_linux_write_pages,
+#else
   .writepage =		afs_linux_writepage,
+#endif
 #if defined(STRUCT_ADDRESS_SPACE_OPERATIONS_HAS_DIRTY_FOLIO) && \
     defined(HAVE_LINUX_BLOCK_DIRTY_FOLIO)
   .dirty_folio =	block_dirty_folio,
diff --git a/src/cf/linux-kernel-assorted.m4 b/src/cf/linux-kernel-assorted.m4
index 4c185554d..21cec3669 100644
--- a/src/cf/linux-kernel-assorted.m4
+++ b/src/cf/linux-kernel-assorted.m4
@@ -61,6 +61,7 @@ LINUX_KERNEL_READ_OFFSET_IS_LAST
 LINUX_KEYRING_SEARCH_TAKES_RECURSE
 LINUX_GENERIC_FILLATTR_TAKES_REQUEST_MASK
 LINUX_FILE_LOCK_CORE
+LINUX_WRITEPAGES_USES_FOLIOS
 ])
 
 
diff --git a/src/cf/linux-test4.m4 b/src/cf/linux-test4.m4
index c7c0c2318..4155def67 100644
--- a/src/cf/linux-test4.m4
+++ b/src/cf/linux-test4.m4
@@ -902,4 +902,24 @@ AC_DEFUN([LINUX_DOP_D_REVALIDATE_TAKES_PARENT_INODE], [
                        [DOP_REVALIDATE_TAKES_PARENT_INODE],
                        [define if your dops.d_revalidate takes a parent inode],
                        [-Werror])
-])
\ No newline at end of file
+])
+
+dnl Linux 6.16 removed the address_space_operations writepage as part
+dnl of Linux's page to folio transistion. Convert from providing aop->writepage
+dnl to providing aop->writepages and use Linux's write_cache_pages with a callback.
+dnl Test to see whether write_cache_pages uses folios to determine if writepages
+dnl should be implemented.
+AC_DEFUN([LINUX_WRITEPAGES_USES_FOLIOS], [
+  AC_CHECK_LINUX_BUILD([whether aop.writepages can use folios],
+                       [ac_cv_linux_writepages_uses_folios],
+                       [[#include <linux/writeback.h>
+                         #include <linux/mm_types.h>
+                         static int writepages_cb(struct folio *folio,
+                                                  struct writeback_control *wbc,
+                                                  void *priv) { return 0; }]],
+                       [[static int code;
+                         code = write_cache_pages(NULL, NULL, writepages_cb, NULL);]],
+                       [[LINUX_WRITEPAGES_USES_FOLIOS]],
+                       [[define if aop.writepages can use folios]],
+                       [[-Werror]])
+])
-- 
2.51.0

